import * as tsMod from "typescript";
import { SourceFile, Program, Expression, Identifier, Node } from "typescript";
import * as tsServer from "typescript/lib/tsserverlibrary";
import { HTMLDataV1 } from "vscode-html-languageservice";
import { ComponentDeclaration, ComponentDefinition, ComponentMember, AnalyzerResult, ComponentCssPart, ComponentCssProperty, ComponentEvent, ComponentSlot } from "web-component-analyzer";
import { SimpleType } from "ts-simple-type";
interface Range {
    start: number;
    end: number;
} // Offsets and positions
// Offsets and positions
type DocumentOffset = number;
type SourceFilePosition = number; /*export type DocumentOffset = number & { _documentOffset: void };

export type SourceFilePosition = number & { _sourceFilePosition: void };*/
/*export function makeDocumentOffset(offset: number): DocumentOffset {
return offset as DocumentOffset;
}

export function makeDocumentPosition(position: number): SourceFilePosition {
return position as SourceFilePosition;
}*/
// Ranges
/*export type DocumentOffset = number & { _documentOffset: void };

export type SourceFilePosition = number & { _sourceFilePosition: void };*/
/*export function makeDocumentOffset(offset: number): DocumentOffset {
return offset as DocumentOffset;
}

export function makeDocumentPosition(position: number): SourceFilePosition {
return position as SourceFilePosition;
}*/
// Ranges
type DocumentRange = {
    start: DocumentOffset;
    end: DocumentOffset;
} & {
    _brand: "document";
};
type SourceFileRange = {
    start: SourceFilePosition;
    end: SourceFilePosition;
} & {
    _brand: "sourcefile";
};
type LitDiagnosticSeverity = "error" | "warning";
interface LitDiagnostic {
    location: SourceFileRange;
    code?: number;
    message: string;
    fixMessage?: string;
    suggestion?: string;
    source: LitAnalyzerRuleId;
    severity: LitDiagnosticSeverity;
    file: SourceFile;
}
type LitAnalyzerRuleSeverity = "on" | "off" | "warn" | "warning" | "error" | 0 | 1 | 2 | true | false;
type LitAnalyzerRuleId = "no-unknown-tag-name" | "no-missing-import" | "no-unclosed-tag" | "no-unknown-attribute" | "no-unknown-property" | "no-unknown-event" | "no-unknown-slot" | "no-unintended-mixed-binding" | "no-invalid-boolean-binding" | "no-expressionless-property-binding" | "no-noncallable-event-binding" | "no-boolean-in-attribute-binding" | "no-complex-attribute-binding" | "no-nullable-attribute-binding" | "no-incompatible-type-binding" | "no-invalid-directive-binding" | "no-incompatible-property-type" | "no-invalid-attribute-name" | "no-invalid-tag-name" | "no-invalid-css" | "no-property-visibility-mismatch" | "no-legacy-attribute" | "no-missing-element-type-definition";
type LitAnalyzerRules = Partial<Record<LitAnalyzerRuleId, LitAnalyzerRuleSeverity | [LitAnalyzerRuleSeverity]>>; /**
 * The values of this map are tuples where 1st element is
 * non-strict severity and 2nd element is "strict" severity
 */
/**
 * The values of this map are tuples where 1st element is
 * non-strict severity and 2nd element is "strict" severity
 */
/**
 * The values of this map are tuples where 1st element is
 * non-strict severity and 2nd element is "strict" severity
 */
// All rule names order alphabetically
declare const ALL_RULE_IDS: LitAnalyzerRuleId[]; // This map is based on alphabetic order, so it assumed that
//   these rule codes are changed when new rules are added and
//   should not be depended on by the user.
// The user should always use the "rule id" string.
// Consider if this map should be manually maintained in the future.
// This map is based on alphabetic order, so it assumed that
//   these rule codes are changed when new rules are added and
//   should not be depended on by the user.
// The user should always use the "rule id" string.
// Consider if this map should be manually maintained in the future.
declare const RULE_ID_CODE_MAP: Record<LitAnalyzerRuleId, number>;
declare function ruleIdCode(ruleId: LitAnalyzerRuleId): number;
declare function ruleSeverity(rules: LitAnalyzerConfig | LitAnalyzerRules, ruleId: LitAnalyzerRuleId): LitAnalyzerRuleSeverity;
declare function isRuleDisabled(config: LitAnalyzerConfig, ruleId: LitAnalyzerRuleId): boolean;
declare function isRuleEnabled(config: LitAnalyzerConfig, ruleId: LitAnalyzerRuleId): boolean;
declare function litDiagnosticRuleSeverity(config: LitAnalyzerConfig, ruleId: LitAnalyzerRuleId): LitDiagnosticSeverity;
type LitAnalyzerLogging = "off" | "error" | "warn" | "debug" | "verbose";
type LitSecuritySystem = "off" | "ClosureSafeTypes";
interface LitAnalyzerConfig {
    strict: boolean;
    rules: LitAnalyzerRules;
    securitySystem: LitSecuritySystem;
    disable: boolean;
    logging: LitAnalyzerLogging;
    cwd: string;
    format: {
        disable: boolean;
    };
    dontShowSuggestions: boolean;
    dontSuggestConfigChanges: boolean;
    maxNodeModuleImportDepth: number;
    maxProjectImportDepth: number;
    htmlTemplateTags: string[];
    cssTemplateTags: string[];
    globalTags: string[];
    globalAttributes: string[];
    globalEvents: string[];
    customHtmlData: (string | HTMLDataV1)[] | string | HTMLDataV1;
}
/**
 * Parses a partial user configuration and returns a full options object with defaults.
 * @param userOptions
 */
declare function makeConfig(userOptions?: Partial<LitAnalyzerConfig>): LitAnalyzerConfig;
/*function getDeprecatedRule(userOptions: Partial<LitAnalyzerConfig>, name: string): LitAnalyzerRuleSeverity | undefined {
return userOptions.rules?.[name as never];
}*/
declare function makeRules(userOptions: Partial<LitAnalyzerConfig>): LitAnalyzerRules;
/* eslint-disable @typescript-eslint/no-explicit-any */
interface LitAnalyzerLogger {
    level: LitAnalyzerLoggerLevel;
    debug(...args: any[]): void;
    error(...args: any[]): void;
    warn(...args: any[]): void;
    verbose(...args: any[]): void;
}
declare enum LitAnalyzerLoggerLevel {
    OFF = 0,
    ERROR = 1,
    WARN = 2,
    DEBUG = 3,
    VERBOSE = 4
}
declare class DefaultLitAnalyzerLogger implements LitAnalyzerLogger {
    level: LitAnalyzerLoggerLevel;
    /**
     * Logs if this.level >= DEBUG
     * @param args
     */
    debug(...args: any[]): void;
    /**
     * Logs if this.level >= ERROR
     * @param args
     */
    error(...args: any[]): void;
    /**
     * Logs if level >= WARN
     * @param args
     */
    warn(...args: any[]): void;
    /**
     * Logs if level >= VERBOSE
     * @param args
     */
    verbose(...args: any[]): void;
    private log;
    protected severityPrefix(level: LitAnalyzerLoggerLevel): string;
}
type LitHtmlAttributeModifier = "." | "?" | "@";
declare const LIT_HTML_PROP_ATTRIBUTE_MODIFIER = ".";
declare const LIT_HTML_BOOLEAN_ATTRIBUTE_MODIFIER = "?";
declare const LIT_HTML_EVENT_LISTENER_ATTRIBUTE_MODIFIER = "@";
declare const LIT_HTML_ATTRIBUTE_MODIFIERS: LitHtmlAttributeModifier[];
declare const DIAGNOSTIC_SOURCE = "lit-plugin";
declare const TS_IGNORE_FLAG = "@ts-ignore";
declare const VERSION = "1.2.1";
declare const MAX_RUNNING_TIME_PER_OPERATION = 150; // Default to small timeouts. Opt in to larger timeouts where necessary.
// Default to small timeouts. Opt in to larger timeouts where necessary.
// Default to small timeouts. Opt in to larger timeouts where necessary.
declare enum HtmlNodeAttrAssignmentKind {
    BOOLEAN = "BOOLEAN",
    EXPRESSION = "EXPRESSION",
    STRING = "STRING",
    MIXED = "MIXED"
}
interface IHtmlNodeAttrAssignmentBase {
    location?: Range;
    htmlAttr: HtmlNodeAttr;
}
interface IHtmlNodeAttrAssignmentExpression extends IHtmlNodeAttrAssignmentBase {
    kind: HtmlNodeAttrAssignmentKind.EXPRESSION;
    location: Range;
    expression: Expression;
}
interface IHtmlNodeAttrAssignmentString extends IHtmlNodeAttrAssignmentBase {
    kind: HtmlNodeAttrAssignmentKind.STRING;
    location: Range;
    value: string;
}
interface IHtmlNodeAttrAssignmentBoolean extends IHtmlNodeAttrAssignmentBase {
    kind: HtmlNodeAttrAssignmentKind.BOOLEAN;
}
interface IHtmlNodeAttrAssignmentMixed extends IHtmlNodeAttrAssignmentBase {
    kind: HtmlNodeAttrAssignmentKind.MIXED;
    location: Range;
    values: (Expression | string)[];
}
type HtmlNodeAttrAssignment = IHtmlNodeAttrAssignmentBoolean | IHtmlNodeAttrAssignmentExpression | IHtmlNodeAttrAssignmentString | IHtmlNodeAttrAssignmentMixed;
interface IHtmlNodeSourceCodeLocation extends Range {
    name: Range;
    startTag: Range;
    endTag?: Range;
}
declare enum HtmlNodeKind {
    NODE = "NODE",
    SVG = "SVG",
    STYLE = "STYLE"
}
interface IHtmlNodeBase {
    tagName: string;
    location: IHtmlNodeSourceCodeLocation;
    attributes: HtmlNodeAttr[];
    parent?: HtmlNode;
    children: HtmlNode[];
    selfClosed: boolean;
    document: HtmlDocument;
}
interface IHtmlNode extends IHtmlNodeBase {
    kind: HtmlNodeKind.NODE;
}
interface IHtmlNodeStyleTag extends IHtmlNodeBase {
    kind: HtmlNodeKind.STYLE;
}
interface IHtmlNodeSvgTag extends IHtmlNodeBase {
    kind: HtmlNodeKind.SVG;
}
type HtmlNode = IHtmlNode | IHtmlNodeStyleTag | IHtmlNodeSvgTag;
declare enum HtmlNodeAttrKind {
    EVENT_LISTENER = "EVENT_LISTENER",
    ATTRIBUTE = "ATTRIBUTE",
    BOOLEAN_ATTRIBUTE = "BOOLEAN_ATTRIBUTE",
    PROPERTY = "PROPERTY"
}
interface IHtmlNodeAttrSourceCodeLocation extends Range {
    name: Range;
}
interface IHtmlNodeAttrBase {
    name: string;
    modifier?: LitHtmlAttributeModifier;
    location: IHtmlNodeAttrSourceCodeLocation;
    assignment?: HtmlNodeAttrAssignment;
    htmlNode: HtmlNode;
    document: HtmlDocument;
}
interface IHtmlNodeAttrEventListener extends IHtmlNodeAttrBase {
    kind: HtmlNodeAttrKind.EVENT_LISTENER;
    modifier: "@";
}
interface IHtmlNodeAttrProp extends IHtmlNodeAttrBase {
    kind: HtmlNodeAttrKind.PROPERTY;
    modifier: ".";
}
interface IHtmlNodeBooleanAttribute extends IHtmlNodeAttrBase {
    kind: HtmlNodeAttrKind.BOOLEAN_ATTRIBUTE;
    modifier: "?";
}
interface IHtmlNodeAttr extends IHtmlNodeAttrBase {
    kind: HtmlNodeAttrKind.ATTRIBUTE;
    modifier: undefined;
}
type HtmlNodeAttr = IHtmlNodeAttrEventListener | IHtmlNodeAttrProp | IHtmlNodeAttr | IHtmlNodeBooleanAttribute;
interface VirtualDocument {
    fileName: string;
    location: SourceFileRange;
    text: string;
    getPartsAtDocumentRange(range?: DocumentRange): (Expression | string)[];
    sfPositionToDocumentOffset(position: SourceFilePosition): DocumentOffset;
    documentOffsetToSFPosition(offset: DocumentOffset): SourceFilePosition;
}
declare class TextDocument {
    virtualDocument: VirtualDocument;
    constructor(virtualDocument: VirtualDocument);
}
declare class HtmlDocument extends TextDocument {
    rootNodes: HtmlNode[];
    constructor(virtualDocument: VirtualDocument, rootNodes: HtmlNode[]);
    htmlAttrAreaAtOffset(offset: DocumentOffset | DocumentRange): HtmlNode | undefined;
    htmlAttrAssignmentAtOffset(offset: DocumentOffset | DocumentRange): HtmlNodeAttr | undefined;
    htmlAttrNameAtOffset(offset: DocumentOffset | DocumentRange): HtmlNodeAttr | undefined;
    htmlNodeNameAtOffset(offset: DocumentOffset | DocumentRange): HtmlNode | undefined;
    htmlNodeOrAttrAtOffset(offset: DocumentOffset | DocumentRange): HtmlNode | HtmlNodeAttr | undefined;
    /**
     * Finds the closest node to offset.
     * This method can be used to find out which tag to close in the HTML.
     * @param offset
     */
    htmlNodeClosestToOffset(offset: DocumentOffset): HtmlNode | undefined;
    findAttr(test: (node: HtmlNodeAttr) => boolean): HtmlNodeAttr | undefined;
    findNode(test: (node: HtmlNode) => boolean): HtmlNode | undefined;
    mapNodes<T>(map: (node: HtmlNode) => T): T[];
    private mapFindOne;
}
type RuleFixActionKind = "changeTagName" | "addAttribute" | "changeAttributeName" | "changeAttributeModifier" | "changeAssignment" | "import" | "extendGlobalDeclaration" | "changeRange" | "changeIdentifier";
interface RuleFixActionBase {
    kind: RuleFixActionKind;
    file?: SourceFile;
}
interface RuleFixActionChangeTagName extends RuleFixActionBase {
    kind: "changeTagName";
    htmlNode: HtmlNode;
    newName: string;
}
interface RuleFixActionAddAttribute extends RuleFixActionBase {
    kind: "addAttribute";
    htmlNode: HtmlNode;
    name: string;
    value?: string;
}
interface RuleFixActionChangeAttributeName extends RuleFixActionBase {
    kind: "changeAttributeName";
    htmlAttr: HtmlNodeAttr;
    newName: string;
}
interface RuleFixActionChangeAttributeModifier extends RuleFixActionBase {
    kind: "changeAttributeModifier";
    htmlAttr: HtmlNodeAttr;
    newModifier: string;
}
interface RuleFixActionChangeAssignment extends RuleFixActionBase {
    kind: "changeAssignment";
    assignment: HtmlNodeAttrAssignment;
    newValue: string;
}
interface RuleFixActionChangeIdentifier extends RuleFixActionBase {
    kind: "changeIdentifier";
    identifier: Identifier;
    newText: string;
}
interface RuleFixActionImport extends RuleFixActionBase {
    kind: "import";
    file: SourceFile;
    path: string;
    identifiers?: string[];
}
interface RuleFixActionChangeRange extends RuleFixActionBase {
    kind: "changeRange";
    range: SourceFileRange;
    newText: string;
}
interface RuleFixActionExtendGlobalDeclaration extends RuleFixActionBase {
    kind: "extendGlobalDeclaration";
    name: string;
    newMembers: string[];
}
type RuleFixAction = RuleFixActionChangeTagName | RuleFixActionAddAttribute | RuleFixActionChangeAttributeName | RuleFixActionImport | RuleFixActionChangeAttributeModifier | RuleFixActionChangeAssignment | RuleFixActionChangeIdentifier | RuleFixActionExtendGlobalDeclaration | RuleFixActionChangeRange;
interface RuleFix {
    message: string;
    actions: RuleFixAction[];
}
interface RuleDiagnostic {
    location: SourceFileRange;
    message: string;
    fixMessage?: string;
    suggestion?: string;
    fix?: () => RuleFix[] | RuleFix;
}
interface AnalyzerDefinitionStore {
    getAnalysisResultForFile(sourceFile: SourceFile): AnalyzerResult | undefined;
    getDefinitionsWithDeclarationInFile(sourceFile: SourceFile): ComponentDefinition[];
    getComponentDeclarationsInFile(sourceFile: SourceFile): ComponentDeclaration[];
    getDefinitionForTagName(tagName: string): ComponentDefinition | undefined;
    getDefinitionsInFile(sourceFile: SourceFile): ComponentDefinition[];
}
interface AnalyzerDependencyStore {
    hasTagNameBeenImported(fileName: string, tagName: string): boolean;
} //importedComponentDefinitionsInFile = new Map<string, ComponentDefinition[]>();
/**
 * Returns if a component for a specific file has been imported.
 * @param fileName
 * @param tagName
 */
/*hasTagNameBeenImported(fileName: string, tagName: string): boolean {
for (const file of this.importedComponentDefinitionsInFile.get(fileName) || []) {
if (file.tagName === tagName) {
return true;
}
}

return false;
}*/
//importedComponentDefinitionsInFile = new Map<string, ComponentDefinition[]>();
/**
 * Returns if a component for a specific file has been imported.
 * @param fileName
 * @param tagName
 */
/*hasTagNameBeenImported(fileName: string, tagName: string): boolean {
for (const file of this.importedComponentDefinitionsInFile.get(fileName) || []) {
if (file.tagName === tagName) {
return true;
}
}

return false;
}*/
//importedComponentDefinitionsInFile = new Map<string, ComponentDefinition[]>();
/**
 * Returns if a component for a specific file has been imported.
 * @param fileName
 * @param tagName
 */
/*hasTagNameBeenImported(fileName: string, tagName: string): boolean {
for (const file of this.importedComponentDefinitionsInFile.get(fileName) || []) {
if (file.tagName === tagName) {
return true;
}
}

return false;
}*/
interface AnalyzerDocumentStore {
    getDocumentAtPosition(sourceFile: SourceFile, position: SourceFilePosition, options: LitAnalyzerConfig): TextDocument | undefined;
    getDocumentsInFile(sourceFile: SourceFile, config: LitAnalyzerConfig): TextDocument[];
}
interface HtmlDataFeatures {
    attributes: HtmlAttr[];
    properties: HtmlProp[];
    events: HtmlEvent[];
    slots: HtmlSlot[];
    cssParts: HtmlCssPart[];
    cssProperties: HtmlCssProperty[];
}
interface HtmlDataCollection {
    tags: HtmlTag[];
    global: Partial<HtmlDataFeatures>;
}
interface NamedHtmlDataCollection {
    tags: string[];
    global: Partial<Record<keyof HtmlDataFeatures, string[]>>;
}
interface HtmlTag extends HtmlDataFeatures {
    tagName: string;
    description?: string;
    builtIn?: boolean;
    global?: boolean;
    declaration?: ComponentDeclaration;
}
type HtmlTagMemberKind = "attribute" | "property";
interface HtmlMemberBase {
    kind?: HtmlTagMemberKind;
    builtIn?: boolean;
    required?: boolean;
    description?: string;
    declaration?: ComponentMember;
    name?: string;
    fromTagName?: string;
    related?: HtmlMember[];
    getType(): SimpleType;
}
interface HtmlAttr extends HtmlMemberBase {
    kind: "attribute";
    name: string;
    related?: HtmlMember[];
}
interface HtmlProp extends HtmlMemberBase {
    kind: "property";
    name: string;
    related?: HtmlMember[];
}
type HtmlMember = HtmlAttr | HtmlProp;
interface HtmlEvent {
    name: string;
    description?: string;
    declaration?: ComponentEvent;
    builtIn?: boolean;
    global?: boolean;
    fromTagName?: string;
    related?: HtmlEvent[];
    getType(): SimpleType;
}
interface HtmlSlot {
    name: string;
    fromTagName?: string;
    description?: string;
    declaration?: ComponentSlot;
    related?: HtmlCssPart[];
}
interface HtmlCssPart {
    name: string;
    fromTagName?: string;
    description?: string;
    declaration?: ComponentCssPart;
    related?: HtmlCssPart[];
}
interface HtmlCssProperty {
    name: string;
    fromTagName?: string;
    description?: string;
    typeHint?: string;
    declaration?: ComponentCssProperty;
    related?: HtmlCssProperty[];
}
type HtmlAttrTarget = HtmlEvent | HtmlMember;
interface AnalyzerHtmlStore {
    /*absorbAnalysisResult(sourceFile: SourceFile, result: AnalyzeComponentsResult): void;
    absorbSubclassExtension(name: string, extension: HtmlTag): void;
    absorbCollection(collection: HtmlDataCollection, register: HtmlStoreDataSource): void;
    forgetTagsDefinedInFile(sourceFile: SourceFile): void;*/
    /*getDefinitionsWithDeclarationInFile(sourceFile: SourceFile): ComponentDefinition[];
    getDefinitionForTagName(tagName: string): ComponentDefinition | undefined;
    getDefinitionsInFile(sourceFile: SourceFile): ComponentDefinition[];
    hasTagNameBeenImported(fileName: string, tagName: string): boolean;*/
    getHtmlTag(htmlNode: HtmlNode | string): HtmlTag | undefined;
    getGlobalTags(): Iterable<HtmlTag>;
    getAllAttributesForTag(htmlNode: HtmlNode | string): Iterable<HtmlAttr>;
    getAllPropertiesForTag(htmlNode: HtmlNode | string): Iterable<HtmlProp>;
    getAllEventsForTag(htmlNode: HtmlNode | string): Iterable<HtmlEvent>;
    getAllSlotsForTag(htmlNode: HtmlNode | string): Iterable<HtmlSlot>;
    getAllCssPartsForTag(htmlNode: HtmlNode | string): Iterable<HtmlCssPart>;
    getAllCssPropertiesForTag(htmlNode: HtmlNode | string): Iterable<HtmlCssProperty>;
    getHtmlAttrTarget(htmlNodeAttr: IHtmlNodeAttrProp): HtmlProp | undefined;
    getHtmlAttrTarget(htmlNodeAttr: IHtmlNodeAttr | IHtmlNodeBooleanAttribute): HtmlAttr | undefined;
    getHtmlAttrTarget(htmlNodeAttr: IHtmlNodeAttr | IHtmlNodeBooleanAttribute | IHtmlNodeAttrProp): HtmlMember | undefined;
    getHtmlAttrTarget(htmlNodeAttr: IHtmlNodeAttrEventListener): HtmlEvent | undefined;
    getHtmlAttrTarget(htmlNodeAttr: HtmlNodeAttr): HtmlAttrTarget | undefined;
    getHtmlAttrTarget(htmlNodeAttr: HtmlNodeAttr): HtmlAttrTarget | undefined;
}
interface RuleModuleContext {
    readonly ts: typeof tsMod;
    readonly program: Program;
    readonly file: SourceFile;
    readonly htmlStore: AnalyzerHtmlStore;
    readonly dependencyStore: AnalyzerDependencyStore;
    readonly documentStore: AnalyzerDocumentStore;
    readonly definitionStore: AnalyzerDefinitionStore;
    readonly logger: LitAnalyzerLogger;
    readonly config: LitAnalyzerConfig;
    report(diagnostic: RuleDiagnostic): void;
    break(): void;
}
type RuleModulePriority = "low" | "medium" | "high"; //export type RuleModuleCategory = "HTML" | "CSS" | "Component";
//export type RuleModuleCategory = "HTML" | "CSS" | "Component";
interface RuleModuleImplementation {
    // Document based rules
    visitHtmlNode?(node: HtmlNode, context: RuleModuleContext): void;
    visitHtmlAttribute?(attribute: HtmlNodeAttr, context: RuleModuleContext): void;
    visitHtmlAssignment?(assignment: HtmlNodeAttrAssignment, context: RuleModuleContext): void;
    // Component based rules
    visitComponentDefinition?(definition: ComponentDefinition, context: RuleModuleContext): void;
    visitComponentDeclaration?(declaration: ComponentDeclaration, context: RuleModuleContext): void;
    visitComponentMember?(declaration: ComponentMember, context: RuleModuleContext): void;
}
interface RuleModule extends RuleModuleImplementation {
    id: LitAnalyzerRuleId;
    meta?: {
        priority?: RuleModulePriority; /*docs?: {
        description: string;
        category: RuleModuleCategory;
        };*/
        /*docs?: {
        description: string;
        category: RuleModuleCategory;
        };*/
        /*docs?: {
        description: string;
        category: RuleModuleCategory;
        };*/
    };
}
interface ReportedRuleDiagnostic {
    source: LitAnalyzerRuleId;
    diagnostic: RuleDiagnostic;
}
declare class RuleCollection {
    private rules;
    push(...rule: RuleModule[]): void;
    private invokeRules;
    getDiagnosticsFromDeclaration(declaration: ComponentDeclaration, baseContext: LitAnalyzerContext): ReportedRuleDiagnostic[];
    getDiagnosticsFromDefinition(definition: ComponentDefinition, baseContext: LitAnalyzerContext): ReportedRuleDiagnostic[];
    getDiagnosticsFromDocument(htmlDocument: HtmlDocument, baseContext: LitAnalyzerContext): ReportedRuleDiagnostic[];
}
interface LitAnalyzerContext {
    readonly ts: typeof tsMod;
    readonly program: Program;
    readonly project: tsServer.server.Project | undefined;
    readonly config: LitAnalyzerConfig;
    // Stores
    readonly htmlStore: AnalyzerHtmlStore;
    readonly dependencyStore: AnalyzerDependencyStore;
    readonly documentStore: AnalyzerDocumentStore;
    readonly definitionStore: AnalyzerDefinitionStore;
    readonly logger: LitAnalyzerLogger;
    readonly rules: RuleCollection;
    readonly currentFile: SourceFile;
    readonly currentRunningTime: number;
    readonly isCancellationRequested: boolean;
    updateConfig(config: LitAnalyzerConfig): void;
    updateDependencies(file: SourceFile): void;
    updateComponents(file: SourceFile): void;
    setContextBase(contextBase: LitAnalyzerContextBaseOptions): void;
}
interface LitAnalyzerContextBaseOptions {
    file: SourceFile | undefined;
    timeout?: number;
    throwOnCancellation?: boolean;
}
interface LitPluginContextHandler {
    ts?: typeof tsMod;
    getProgram(): Program;
    getProject?(): tsServer.server.Project;
}
interface LitClosingTagInfo {
    newText: string;
}
interface LitCodeFixAction {
    range: SourceFileRange;
    newText: string;
}
interface LitCodeFix {
    name: string;
    message: string;
    actions: LitCodeFixAction[];
}
type LitTargetKind = "memberFunctionElement" | "functionElement" | "constructorImplementationElement" | "variableElement" | "classElement" | "interfaceElement" | "moduleElement" | "memberVariableElement" | "constElement" | "enumElement" | "keyword" | "constElement" | "alias" | "moduleElement" | "member" | "label" | "unknown";
interface LitCompletion {
    name: string;
    kind: LitTargetKind;
    kindModifiers?: "color";
    insert: string;
    range?: SourceFileRange;
    importance?: "high" | "medium" | "low";
    sortText?: string;
    documentation?(): string | undefined;
}
interface LitCompletionDetails {
    name: string;
    kind: LitTargetKind;
    primaryInfo: string;
    secondaryInfo?: string;
}
type LitDefinitionTargetKind = "node" | "range";
interface LitDefinitionTargetBase {
    kind: LitDefinitionTargetKind;
}
interface LitDefinitionTargetNode extends LitDefinitionTargetBase {
    kind: "node";
    node: Node;
    name?: string;
}
interface LitDefinitionTargetRange {
    kind: "range";
    sourceFile: SourceFile;
    range: SourceFileRange;
    name?: string;
}
type LitDefinitionTarget = LitDefinitionTargetNode | LitDefinitionTargetRange;
interface LitDefinition {
    fromRange: SourceFileRange;
    target: LitDefinitionTarget[] | LitDefinitionTarget;
}
interface LitFormatEdit {
    range: SourceFileRange;
    newText: string;
}
declare enum LitOutliningSpanKind {
    Comment = "comment",
    Region = "region",
    Code = "code",
    Imports = "imports"
}
interface LitOutliningSpan {
    location: SourceFileRange;
    bannerText: string;
    autoCollapse?: boolean;
    kind: LitOutliningSpanKind;
}
interface LitQuickInfo {
    range: SourceFileRange;
    primaryInfo: string;
    secondaryInfo?: string;
}
interface RenameInfoBase {
    kind: LitTargetKind;
    displayName: string;
    fullDisplayName: string;
    range: SourceFileRange;
}
interface RenameHtmlNodeInfo extends RenameInfoBase {
    document: HtmlDocument;
    target: ComponentDefinition | HtmlNode;
}
interface RenameComponentDefinitionInfo extends RenameInfoBase {
    target: ComponentDefinition;
}
type LitRenameInfo = RenameHtmlNodeInfo | RenameComponentDefinitionInfo;
interface LitRenameLocation {
    fileName: string;
    prefixText?: string;
    suffixText?: string;
    range: SourceFileRange;
}
declare class LitAnalyzer {
    private context;
    private litHtmlDocumentAnalyzer;
    private litCssDocumentAnalyzer;
    private componentAnalyzer;
    constructor(context: LitAnalyzerContext);
    getOutliningSpansInFile(file: SourceFile): LitOutliningSpan[];
    getDefinitionAtPosition(file: SourceFile, position: SourceFilePosition): LitDefinition | undefined;
    getQuickInfoAtPosition(file: SourceFile, position: SourceFilePosition): LitQuickInfo | undefined;
    getRenameInfoAtPosition(file: SourceFile, position: SourceFilePosition): LitRenameInfo | undefined;
    getRenameLocationsAtPosition(file: SourceFile, position: SourceFilePosition): LitRenameLocation[];
    getClosingTagAtPosition(file: SourceFile, position: SourceFilePosition): LitClosingTagInfo | undefined;
    getCompletionDetailsAtPosition(file: SourceFile, position: SourceFilePosition, name: string): LitCompletionDetails | undefined;
    getCompletionsAtPosition(file: SourceFile, position: SourceFilePosition): LitCompletion[] | undefined;
    getDiagnosticsInFile(file: SourceFile): LitDiagnostic[];
    getCodeFixesAtPositionRange(file: SourceFile, sourceFileRange: Range): LitCodeFix[];
    getFormatEditsInFile(file: SourceFile, settings: ts.FormatCodeSettings): LitFormatEdit[];
    private getDocumentAndOffsetAtPosition;
    private getDocumentsInFile;
}
declare class DefaultAnalyzerDefinitionStore implements AnalyzerDefinitionStore {
    private analysisResultForFile;
    private definitionForTagName;
    private intersectingDefinitionsForFile;
    absorbAnalysisResult(sourceFile: SourceFile, result: AnalyzerResult): void;
    forgetAnalysisResultForFile(sourceFile: SourceFile): void;
    getAnalysisResultForFile(sourceFile: SourceFile): AnalyzerResult | undefined;
    getDefinitionsWithDeclarationInFile(sourceFile: SourceFile): ComponentDefinition[];
    getComponentDeclarationsInFile(sourceFile: SourceFile): ComponentDeclaration[];
    getDefinitionForTagName(tagName: string): ComponentDefinition | undefined;
    getDefinitionsInFile(sourceFile: SourceFile): ComponentDefinition[];
}
declare class DefaultAnalyzerDependencyStore implements AnalyzerDependencyStore {
    importedComponentDefinitionsInFile: Map<string, ComponentDefinition[]>;
    absorbComponentDefinitionsForFile(sourceFile: SourceFile, result: ComponentDefinition[]): void;
    /**
     * Returns if a component for a specific file has been imported.
     * @param fileName
     * @param tagName
     */
    hasTagNameBeenImported(fileName: string, tagName: string): boolean;
}
declare class DefaultAnalyzerDocumentStore implements AnalyzerDocumentStore {
    getDocumentAtPosition(sourceFile: SourceFile, position: SourceFilePosition, options: LitAnalyzerConfig): TextDocument | undefined;
    getDocumentsInFile(sourceFile: SourceFile, config: LitAnalyzerConfig): TextDocument[];
}
declare enum HtmlDataSourceKind {
    DECLARED = 0,
    USER = 1,
    BUILT_IN = 2,
    BUILT_IN_DECLARED = 3
}
declare class DefaultAnalyzerHtmlStore implements AnalyzerHtmlStore {
    private dataSource;
    absorbSubclassExtension(name: string, extension: HtmlTag): void;
    absorbCollection(collection: HtmlDataCollection, register: HtmlDataSourceKind): void;
    forgetCollection(collection: NamedHtmlDataCollection, register: HtmlDataSourceKind): void;
    getHtmlTag(htmlNode: HtmlNode | string): HtmlTag | undefined;
    getGlobalTags(): Iterable<HtmlTag>;
    getAllAttributesForTag(htmlNode: HtmlNode | string): Iterable<HtmlAttr>;
    getAllPropertiesForTag(htmlNode: HtmlNode | string): Iterable<HtmlProp>;
    getAllEventsForTag(htmlNode: HtmlNode | string): Iterable<HtmlEvent>;
    getAllSlotsForTag(htmlNode: HtmlNode | string): Iterable<HtmlSlot>;
    getAllCssPartsForTag(htmlNode: HtmlNode | string): Iterable<HtmlCssPart>;
    getAllCssPropertiesForTag(htmlNode: HtmlNode | string): Iterable<HtmlCssPart>;
    getHtmlAttrTarget(htmlNodeAttr: IHtmlNodeAttrProp): HtmlProp | undefined;
    getHtmlAttrTarget(htmlNodeAttr: IHtmlNodeAttr | IHtmlNodeBooleanAttribute): HtmlAttr | undefined;
    getHtmlAttrTarget(htmlNodeAttr: IHtmlNodeAttr | IHtmlNodeBooleanAttribute | IHtmlNodeAttrProp): HtmlMember | undefined;
    getHtmlAttrTarget(htmlNodeAttr: IHtmlNodeAttrEventListener): HtmlEvent | undefined;
    getHtmlAttrTarget(htmlNodeAttr: HtmlNodeAttr): HtmlAttrTarget | undefined;
}
type ChangedSourceFileIterator = ((sourceFiles: readonly SourceFile[]) => Iterable<SourceFile>) & {
    invalidate(sourceFile: SourceFile): void;
}; /**
 * Yields source files that have changed since last time this function was called.
 */
/**
 * Yields source files that have changed since last time this function was called.
 */
/**
 * Yields source files that have changed since last time this function was called.
 */
declare class DefaultLitAnalyzerContext implements LitAnalyzerContext {
    private handler;
    protected componentSourceFileIterator: ChangedSourceFileIterator;
    protected hasAnalyzedSubclassExtensions: boolean;
    protected _config: LitAnalyzerConfig;
    get ts(): typeof tsMod;
    get program(): Program;
    get project(): tsServer.server.Project | undefined;
    get config(): LitAnalyzerConfig;
    private _currentStartTime;
    private _currentTimeout;
    get currentRunningTime(): number;
    private _currentCancellationToken;
    private _hasRequestedCancellation;
    private _throwOnRequestedCancellation;
    get isCancellationRequested(): boolean;
    private _currentFile;
    get currentFile(): SourceFile;
    readonly htmlStore: DefaultAnalyzerHtmlStore;
    readonly dependencyStore: DefaultAnalyzerDependencyStore;
    readonly documentStore: DefaultAnalyzerDocumentStore;
    readonly definitionStore: DefaultAnalyzerDefinitionStore;
    readonly logger: DefaultLitAnalyzerLogger;
    private _rules;
    get rules(): RuleCollection;
    setContextBase({ file, timeout, throwOnCancellation }: LitAnalyzerContextBaseOptions): void;
    updateConfig(config: LitAnalyzerConfig): void;
    updateDependencies(file: SourceFile): void;
    updateComponents(file: SourceFile): void;
    private get checker();
    constructor(handler: LitPluginContextHandler);
    private findInvalidatedComponents;
    private findComponentsInFile;
    private analyzeSubclassExtensions;
    private findDependenciesInFile;
}
/**
 * The main function of the cli.
 */
declare function cli(): Promise<void>;
export { LitAnalyzer, LitHtmlAttributeModifier, LIT_HTML_PROP_ATTRIBUTE_MODIFIER, LIT_HTML_BOOLEAN_ATTRIBUTE_MODIFIER, LIT_HTML_EVENT_LISTENER_ATTRIBUTE_MODIFIER, LIT_HTML_ATTRIBUTE_MODIFIERS, DIAGNOSTIC_SOURCE, TS_IGNORE_FLAG, VERSION, MAX_RUNNING_TIME_PER_OPERATION, LitAnalyzerRuleSeverity, LitAnalyzerRuleId, LitAnalyzerRules, ALL_RULE_IDS, RULE_ID_CODE_MAP, ruleIdCode, ruleSeverity, isRuleDisabled, isRuleEnabled, litDiagnosticRuleSeverity, LitAnalyzerLogging, LitSecuritySystem, LitAnalyzerConfig, makeConfig, makeRules, LitAnalyzerContext, LitAnalyzerContextBaseOptions, LitPluginContextHandler, LitAnalyzerLogger, LitAnalyzerLoggerLevel, DefaultLitAnalyzerLogger, DefaultLitAnalyzerContext, Range, DocumentOffset, SourceFilePosition, DocumentRange, SourceFileRange, LitClosingTagInfo, LitCodeFix, LitCodeFixAction, LitCompletion, LitCompletionDetails, LitDefinitionTargetKind, LitDefinitionTargetBase, LitDefinitionTargetNode, LitDefinitionTargetRange, LitDefinitionTarget, LitDefinition, LitDiagnosticSeverity, LitDiagnostic, LitFormatEdit, LitOutliningSpanKind, LitOutliningSpan, LitQuickInfo, RenameInfoBase, RenameHtmlNodeInfo, RenameComponentDefinitionInfo, LitRenameInfo, LitRenameLocation, LitTargetKind, cli };
//# sourceMappingURL=index.cjs.d.ts.map
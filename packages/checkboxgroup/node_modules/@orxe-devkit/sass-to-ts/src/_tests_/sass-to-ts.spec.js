const chokidar = require('chokidar');
const fs = require('file-system');

console.error = jest.fn();

describe('scss-to-ts', () => {
  const fileContent = `import {css} from 'lit-element';\nexport default css\`\`;`;
  const filePath = './src/_tests_/mockdata/mockfile.scss';
  const generatedFilePaths = [
    './src/_tests_/mockdata/mockfile-css.ts',
    './dist/_tests_/mockdata/mockfile.scss',
    './dist/_tests_/mockdata/js/mockfile.js',
    './dist/_tests_/mockdata/ts/mockfile.ts',
    './dist/_tests_/mockdata/css/mockfile.css',
    './src/_tests_/mockdata/mobile-css.ts',
    './src/_tests_/mockdata/wrong-css.ts'
  ];
  let filePromise;
  filePromise = new Promise(async (resolve, reject) => {
    await fs.writeFile(filePath, '', () => { });
    resolve(true);
  });

  beforeAll(() => {
    chokidar.watch = jest.fn().mockImplementation(() => {
      return {
        on: () => {
          return;
        },
      };
    });
  });

  afterAll(async (done) => {
    await setTimeout(() => {
      done();
    }, 200);
  });

  it('should create -css.ts file and check file content', () => {
    filePromise.then(async (complete) => {
      if (complete) {
        await expect(require('../index')).toBeDefined();
        await expect(fs.existsSync(generatedFilePaths[0])).toBeTruthy();
        await expect(fs.readFileSync(generatedFilePaths[0], { encoding: 'utf8', flag: 'r' })).toBe(
          fileContent,
        );
      }
    });
  });

  it('should create dist folder and check file content', () => {
    filePromise.then(async (complete) => {
      if (complete) {
        process.argv = '-theme';
        await expect(require.requireMock('../index')).toBeDefined();
        await expect(fs.existsSync(generatedFilePaths[1])).toBeTruthy();
        await expect(fs.readFileSync(generatedFilePaths[1], { encoding: 'utf8', flag: 'r' })).toBe(
          '',
        );
        await expect(fs.existsSync(generatedFilePaths[2])).toBeTruthy();
        await expect(fs.readFileSync(generatedFilePaths[2], { encoding: 'utf8', flag: 'r' })).toBe(
          fileContent,
        );
        await expect(fs.existsSync(generatedFilePaths[3])).toBeTruthy();
        await expect(fs.readFileSync(generatedFilePaths[3], { encoding: 'utf8', flag: 'r' })).toBe(
          fileContent,
        );
        await expect(fs.existsSync(generatedFilePaths[4])).toBeTruthy();
        await expect(fs.readFileSync(generatedFilePaths[4], { encoding: 'utf8', flag: 'r' })).toBe(
          '',
        );
      }
    });
  });

  it('should create not create -css.ts file and check console error', () => {
    let filepromise = new Promise(async (resolve, reject) => {
      await fs.writeFile('./src/_tests_/mockdata/mockfile1.scss', 'invalid content', () => { });
      resolve(true);
    });
    filepromise.then(async (complete) => {
      if (complete) {
        await expect(require('../index')).toBeDefined();
        await expect(console.error).toHaveBeenCalled();
        await expect(fs.existsSync(generatedFilePaths[6])).toBeFalsy();
      }
    });
  });

  it('should create not -css.ts file ', () => {
    let filepromise = new Promise(async (resolve, reject) => {
      await fs.writeFile('./src/_tests_/mockdata/mockfile2.scss', "@import '~mobile';", () => { });
      resolve(true);
    });
    filepromise.then(async (complete) => {
      if (complete) {
        await expect(require('../index')).toBeDefined();
        await expect(fs.existsSync(generatedFilePaths[5])).toBeFalsy();
      }
    });
  });

});
"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.NoInheritPlugin = void 0;
const index_1 = require("typedoc/dist/lib/models/reflections/index");
const components_1 = require("typedoc/dist/lib/converter/components");
const converter_1 = require("typedoc/dist/lib/converter/converter");
const models_1 = require("typedoc/dist/lib/models");
/**
 * A handler that deals with inherited reflections.
 */
let NoInheritPlugin = class NoInheritPlugin extends components_1.ConverterComponent {
    /**
     * Create a new CommentPlugin instance.
     */
    initialize() {
        this.listenTo(this.owner, converter_1.Converter.EVENT_BEGIN, this.onBegin);
        this.listenTo(this.owner, converter_1.Converter.EVENT_CREATE_DECLARATION, this.onDeclaration, -100); // after CommentPlugin
        this.listenTo(this.owner, converter_1.Converter.EVENT_RESOLVE_BEGIN, this.onBeginResolve);
    }
    /**
     * Triggered when the converter begins converting a project.
     *
     * @param context  The context object describing the current state the converter is in.
     */
    onBegin(context) {
        this.noInherit = [];
        this.inheritedReflections = [];
    }
    /**
     * Triggered when the converter has created a declaration or signature reflection.
     *
     * Builds the list of classes/interfaces that don't inherit docs and
     * the list of reflections that are inherited that could end up being removed.
     *
     * @param context  The context object describing the current state the converter is in.
     * @param reflection  The reflection that is currently processed.
     * @param node  The node that is currently processed if available.
     */
    onDeclaration(context, reflection, node) {
        if (reflection instanceof index_1.DeclarationReflection) {
            // class or interface that won't inherit docs
            if (reflection.kindOf(index_1.ReflectionKind.ClassOrInterface) &&
                reflection.comment && reflection.comment.hasTag('noinheritdoc')) {
                this.noInherit.push(reflection);
                reflection.comment.removeTags('noinheritdoc');
            }
            // class or interface member inherited from a super
            if (reflection.inheritedFrom && reflection.parent && reflection.parent.kindOf(index_1.ReflectionKind.ClassOrInterface) &&
                (!reflection.overwrites || (reflection.overwrites && reflection.overwrites !== reflection.inheritedFrom))) {
                this.inheritedReflections.push(reflection);
            }
        }
    }
    /**
     * Triggered when the converter begins resolving a project.
     *
     * Goes over the list of inherited reflections and removes any that are down the hierarchy
     * from a class that doesn't inherit docs.
     *
     * @param context The context object describing the current state the converter is in.
     */
    onBeginResolve(context) {
        if (this.noInherit) {
            const project = context.project;
            const removals = [];
            this.inheritedReflections.forEach((reflection) => {
                // Look through the inheritance chain for a reflection that is flagged as noInherit for this reflection
                if (this.isNoInheritRecursive(context, reflection, 0)) {
                    removals.push(reflection);
                }
            });
            removals.forEach((removal) => {
                project.removeReflection(removal, true);
            });
        }
    }
    /**
     * Checks whether some DeclarationReflection is in the noInherit list.
     * @param search  The DeclarationReflection to search for in the list.
     */
    isNoInherit(search) {
        if (this.noInherit.find((no) => no.id === search.id && no.name === search.name)) {
            return true;
        }
        return false;
    }
    /**
     * Checks whether some Reflection is in the inheritedReflections list.
     * @param search  The Reflection to search for in the list.
     */
    isInherited(search) {
        if (this.inheritedReflections.find((inh) => inh.id === search.id && inh.name === search.name)) {
            return true;
        }
        return false;
    }
    /**
     * Checks whether some reflection's inheritance chain is broken by a class or interface that doesn't inherit docs.
     * @param context  The context object describing the current state the converter is in.
     * @param current  The current reflection being evaluated for non-inheritance.
     * @param depth  The current recursion depth, used for stopping on excessively long inheritance chains.
     */
    isNoInheritRecursive(context, current, depth) {
        if (depth > 20) {
            this.application.logger.warn(`Found inheritance chain with depth > 20, stopping no inherit check: ${current.getFullName()}`);
            return false; // stop if we've recursed more than 20 times
        }
        // As we move up the chain, check if the reflection parent is in the noInherit list
        const parent = current.parent;
        if (!parent)
            return false;
        if (this.isNoInherit(parent) &&
            (depth === 0 || this.isInherited(current))) {
            return true;
        }
        const checkExtended = (type) => {
            const extended = this.resolveType(context, parent, type);
            if (extended instanceof index_1.Reflection) {
                const upLevel = extended.getChildByName(current.name);
                if (upLevel && this.isNoInheritRecursive(context, upLevel, depth + 1)) {
                    return true;
                }
            }
            return false;
        };
        if (parent.extendedTypes) {
            if (parent.extendedTypes.some(checkExtended)) {
                return true;
            }
        }
        return false;
    }
    /**
     * Takes some ReferenceType and resolves it to a reflection.
     * This is needed because we are operating prior to the TypePlugin resolving types.
     * @param context  The context object describing the current state the converter is in.
     * @param reflection  The reflection context.
     * @param type  The type to find relative to the reflection.
     */
    resolveType(context, reflection, type) {
        const project = context.project;
        if (type instanceof models_1.ReferenceType) {
            if (type.symbolFullyQualifiedName === models_1.ReferenceType.SYMBOL_FQN_RESOLVE_BY_NAME) {
                return reflection.findReflectionByName(type.name);
            }
            else if (!type.reflection && type.symbolFullyQualifiedName !== models_1.ReferenceType.SYMBOL_FQN_RESOLVE_BY_NAME) {
                return project.getReflectionFromFQN(type.symbolFullyQualifiedName);
            }
            else {
                return type.reflection;
            }
        }
        return null;
    }
};
NoInheritPlugin = __decorate([
    components_1.Component({ name: 'no-inherit' })
], NoInheritPlugin);
exports.NoInheritPlugin = NoInheritPlugin;
